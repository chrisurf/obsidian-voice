import {
  PollyClient,
  SynthesizeSpeechCommand,
  DescribeVoicesCommand,
  Engine,
  LanguageCode,
  TextType,
  OutputFormat,
  VoiceId,
} from "@aws-sdk/client-polly";

/**
 * AwsPollyService - AWS Polly integration for text-to-speech
 *
 * Uses new MarkdownToSSMLProcessor pipeline for content processing
 * - Receives pre-processed SSML from TextSpeaker
 * - Handles chunking for AWS size limits
 * - Manages audio playback and caching
 *
 * See: MARKDOWN_TO_SSML_ARCHITECTURE.md for design
 */

interface AwsCredentials {
  credentials: {
    accessKeyId: string;
    secretAccessKey: string;
  };
  region: string;
}

interface SynthesizeInput {
  Engine?: Engine;
  LanguageCode?: LanguageCode;
  SampleRate?: string;
  TextType?: TextType;
  OutputFormat?: OutputFormat;
  VoiceId?: VoiceId;
  Text: string;
}

export class AwsPollyService {
  private audio: HTMLAudioElement;
  private speed: number;
  private synthesizeInput: {
    Engine: Engine;
    LanguageCode: LanguageCode;
    SampleRate: string;
    TextType: TextType;
    OutputFormat: OutputFormat;
    VoiceId: VoiceId;
    Text: string;
  };
  private pollyClient: PollyClient;
  private voiceChanged: boolean;
  private progressCallback?: (progress: number) => void;
  private errorCallback?: (error: string) => void;
  private abortController?: AbortController;
  private isLoading: boolean = false;
  private lastGeneratedAudio: Blob | null = null;
  private lastGeneratedAudioFilePath: string | null = null;
  // Request lock mechanism - prevents concurrent operations
  private currentRequestId: string | null = null;

  constructor(awsConfig: AwsCredentials, voice: string, speed?: number) {
    this.speed = speed || 1.0;
    this.audio = new Audio();
    this.audio.src = "";
    this.voiceChanged = false;

    // Use standard engine for better compatibility in tests
    const engine = process.env.NODE_ENV === "test" ? "standard" : "neural";

    this.synthesizeInput = {
      Engine: engine as Engine,
      SampleRate: "24000",
      TextType: "text" as TextType,
      OutputFormat: "mp3" as OutputFormat,
      LanguageCode: this.getLanguageCode(voice) as LanguageCode,
      VoiceId: (voice || "Stephen") as VoiceId,
      Text: "No document selected.",
    };
    this.pollyClient = new PollyClient({
      credentials: {
        accessKeyId: awsConfig.credentials.accessKeyId,
        secretAccessKey: awsConfig.credentials.secretAccessKey,
      },
      region: awsConfig.region,
    });
  }

  /**
   * Validates AWS credentials by attempting to call DescribeVoices
   * @returns Promise that resolves to validation result
   */
  async validateCredentials(): Promise<{
    isValid: boolean;
    error?: string;
    voiceCount?: number;
  }> {
    try {
      const command = new DescribeVoicesCommand({
        Engine: "neural",
        IncludeAdditionalLanguageCodes: false,
      });

      const response = await this.pollyClient.send(command);

      return {
        isValid: true,
        voiceCount: response.Voices?.length || 0,
      };
    } catch (error: unknown) {
      let errorMessage = "Unknown error occurred";

      if (error && typeof error === "object" && "name" in error) {
        const awsError = error as {
          name: string;
          message?: string;
          code?: string;
        };

        if (awsError.name === "InvalidSignatureException") {
          errorMessage =
            "Invalid AWS credentials - please check your Access Key ID and Secret Access Key";
        } else if (awsError.name === "SignatureDoesNotMatchException") {
          errorMessage =
            "AWS Secret Access Key does not match the Access Key ID";
        } else if (awsError.name === "AccessDeniedException") {
          errorMessage =
            "Access denied - your AWS credentials don't have permission to use Polly";
        } else if (awsError.name === "UnrecognizedClientException") {
          errorMessage = "Invalid AWS Access Key ID format";
        } else if (
          awsError.name === "NetworkingError" ||
          awsError.code === "NetworkingError"
        ) {
          errorMessage =
            "Network error - please check your internet connection";
        } else if (awsError.name === "InvalidParameterValueException") {
          errorMessage = "Invalid AWS region specified";
        } else if (awsError.message) {
          errorMessage = awsError.message;
        }
      }

      return {
        isValid: false,
        error: errorMessage,
      };
    }
  }

  /**
   * Play pre-generated SSML audio with automatic chunking
   * This method accepts SSML that's already been generated by the pipeline
   * and chunks it if necessary for AWS Polly limits
   */
  async playSSMLAudio(
    ssml: string,
    speed?: number,
    filePath?: string,
  ): Promise<void> {
    try {
      // Import chunker dynamically to avoid circular dependencies
      const { chunkSSML, validateChunks } = await import(
        "../processors/pipeline/SSMLChunker"
      );

      // Check if SSML needs chunking (AWS limit is ~3000 chars of text content)
      if (ssml.length > 2500) {
        // Chunk the SSML with conservative limit
        const chunks = chunkSSML(ssml, 2500);

        // Validate chunks
        const validation = validateChunks(chunks);
        if (!validation.isValid) {
          console.error("Chunk validation errors:", validation.errors);
          throw new Error(
            `SSML chunking failed: ${validation.errors.join(", ")}`,
          );
        }

        // Process chunks sequentially
        await this.playSSMLChunks(chunks, speed, filePath);
      } else {
        // Single chunk - use existing flow
        if (ssml === this.synthesizeInput.Text && !this.voiceChanged) {
          this.playAudio(speed);
        } else {
          this.synthesizeInput.Text = ssml;
          await this.callPollySSML(ssml, speed, filePath);
        }
      }

      this.voiceChanged = false;
    } catch (error) {
      if (error instanceof Error && error.name === "AbortError") {
        return;
      }
      console.error("Error in playSSMLAudio:", error);
      this.reportError(error);
      throw error;
    }
  }

  /**
   * Play multiple SSML chunks in sequence
   */
  private async playSSMLChunks(
    chunks: Array<{ ssml: string; index: number; total: number }>,
    speed?: number,
    filePath?: string,
  ): Promise<void> {
    const audioBlobs: Blob[] = [];

    for (const chunk of chunks) {
      if (this.abortController?.signal.aborted) {
        throw new Error("AbortError");
      }

      // Synthesize this chunk
      const blob = await this.synthesizeSSMLChunk(
        chunk.ssml,
        chunk.index,
        chunk.total,
      );
      audioBlobs.push(blob);
    }

    // Concatenate all audio blobs
    const finalBlob = new Blob(audioBlobs, { type: "audio/mpeg" });
    this.lastGeneratedAudio = finalBlob; // Cache for download
    if (filePath) {
      this.lastGeneratedAudioFilePath = filePath;
    }
    this.audio.src = URL.createObjectURL(finalBlob);
    this.reportProgress(1, 1);
    this.playAudio(speed);
  }

  /**
   * Synthesize a single SSML chunk and return the audio blob
   */
  private async synthesizeSSMLChunk(
    ssml: string,
    chunkIndex: number,
    totalChunks: number,
  ): Promise<Blob> {
    this.setLanguageCode(this.getLanguageCode(this.synthesizeInput.VoiceId));

    const input = {
      Engine: this.synthesizeInput.Engine,
      LanguageCode: this.synthesizeInput.LanguageCode,
      SampleRate: this.synthesizeInput.SampleRate,
      TextType: "ssml" as TextType,
      OutputFormat: this.synthesizeInput.OutputFormat,
      Text: ssml,
      VoiceId: this.synthesizeInput.VoiceId,
    };

    const command = new SynthesizeSpeechCommand(input);
    const data = await this.pollyClient.send(command, {
      abortSignal: this.abortController?.signal,
    });

    if (!data || !data.AudioStream) {
      throw new Error("Invalid response from Polly");
    }

    // Read stream to blob
    const audioStream = data.AudioStream;
    if (
      typeof audioStream === "object" &&
      audioStream !== null &&
      "getReader" in audioStream
    ) {
      const readableStream = audioStream as ReadableStream<Uint8Array>;
      const reader = readableStream.getReader();
      const blobParts: BlobPart[] = [];

      const baseProgress = chunkIndex / totalChunks;
      const chunkProgress = 1 / totalChunks;

      while (true) {
        if (this.abortController?.signal.aborted) {
          reader.cancel();
          throw new Error("AbortError");
        }

        const { done, value } = await reader.read();
        if (done) break;

        const chunk = new Uint8Array(value.length);
        chunk.set(value);
        blobParts.push(chunk);

        // Report incremental progress for this chunk
        const progress = baseProgress + chunkProgress * 0.9; // Reserve 10% for concatenation
        this.reportProgress(progress, 1);
      }

      return new Blob(blobParts, { type: "audio/mpeg" });
    }

    // Handle Node.js streams (for testing)
    if (Symbol.asyncIterator in audioStream) {
      const chunks: Buffer[] = [];
      const asyncIterable = audioStream as AsyncIterable<Buffer>;
      for await (const chunk of asyncIterable) {
        if (this.abortController?.signal.aborted) {
          throw new Error("AbortError");
        }
        chunks.push(Buffer.from(chunk));
      }
      const audioBuffer = Buffer.concat(chunks);
      return new Blob([audioBuffer], { type: "audio/mpeg" });
    }

    throw new Error("Unsupported audio stream format");
  }

  /**
   * Call Polly with pre-generated SSML (no chunking, SSML is already prepared)
   */
  private async callPollySSML(
    ssml: string,
    speed?: number,
    filePath?: string,
  ): Promise<void> {
    // Guard: Prevent concurrent AWS calls
    if (this.isLoading) {
      throw new Error(
        "AWS Polly call already in progress. This should not happen if startOperation() guard is working.",
      );
    }

    this.isLoading = true;

    try {
      this.setLanguageCode(this.getLanguageCode(this.synthesizeInput.VoiceId));
      this.reportProgress(0, 1);

      const input = {
        Engine: this.synthesizeInput.Engine,
        LanguageCode: this.synthesizeInput.LanguageCode,
        SampleRate: this.synthesizeInput.SampleRate,
        TextType: "ssml" as TextType,
        OutputFormat: this.synthesizeInput.OutputFormat,
        Text: ssml,
        VoiceId: this.synthesizeInput.VoiceId,
      };

      const command = new SynthesizeSpeechCommand(input);
      const data = await this.pollyClient.send(command, {
        abortSignal: this.abortController?.signal,
      });

      if (this.abortController?.signal.aborted) {
        throw new Error("AbortError");
      }

      if (!data || !data.AudioStream) {
        throw new Error("Invalid response from Polly");
      }

      // Handle audio stream with progress reporting
      const audioStream = data.AudioStream;

      if (typeof audioStream === "object" && audioStream !== null) {
        if ("getReader" in audioStream) {
          const readableStream = audioStream as ReadableStream<Uint8Array>;
          const reader = readableStream.getReader();
          const blobParts: BlobPart[] = [];

          // Track progress during stream reading
          let bytesReceived = 0;
          let progressReported = 0;

          while (true) {
            if (this.abortController?.signal.aborted) {
              reader.cancel();
              throw new Error("AbortError");
            }

            const { done, value } = await reader.read();
            if (done) break;

            const chunk = new Uint8Array(value.length);
            chunk.set(value);
            blobParts.push(chunk);

            // Update progress incrementally
            bytesReceived += value.length;

            // Report progress every ~10% or 50KB to avoid too many updates
            const newProgress = Math.min(0.95, bytesReceived / 500000); // Estimate 500KB total
            if (newProgress - progressReported > 0.1) {
              this.reportProgress(newProgress, 1);
              progressReported = newProgress;
            }
          }

          const audioBlob = new Blob(blobParts, { type: "audio/mpeg" });
          this.lastGeneratedAudio = audioBlob; // Cache for download
          if (filePath) {
            this.lastGeneratedAudioFilePath = filePath;
          }
          this.audio.src = URL.createObjectURL(audioBlob);
          this.reportProgress(1, 1);
          this.playAudio(speed);
        }
      }
    } finally {
      this.isLoading = false;
      this.abortController = undefined;
    }
  }

  async playAudio(speed?: number) {
    let fSpeed =
      typeof speed === "number" ? parseFloat(speed.toFixed(2)) : this.speed;

    if (fSpeed < 0.5) {
      fSpeed = 0.5;
    } else if (fSpeed > 2) {
      fSpeed = 2;
    }

    this.audio.playbackRate = fSpeed;

    this.audio.play();
  }

  pauseAudio() {
    this.audio.pause();
  }

  stopAudio() {
    this.audio.pause();
    this.audio.currentTime = 0;
  }

  /**
   * Check if any operation is currently in progress
   * @returns true if an operation is active
   */
  isOperationInProgress(): boolean {
    return this.currentRequestId !== null;
  }

  /**
   * Start a new operation with UUID tracking
   * @throws Error if operation already in progress
   * @returns Unique request ID for this operation
   */
  startOperation(): string {
    if (this.currentRequestId !== null) {
      throw new Error(
        `Operation already in progress: ${this.currentRequestId}`,
      );
    }

    // Generate cryptographically random UUID
    const requestId = `req_${Date.now()}_${Math.random().toString(36).substring(2, 15)}`;
    this.currentRequestId = requestId;
    this.abortController = new AbortController();

    return requestId;
  }

  /**
   * Validate if the given request ID is still the current active request
   * @param requestId The request ID to validate
   * @returns true if this is the current request
   */
  isCurrentRequest(requestId: string): boolean {
    return this.currentRequestId === requestId;
  }

  /**
   * Cancel the current operation
   */
  cancelOperation(): void {
    if (this.currentRequestId && this.abortController) {
      this.abortController.abort();
      this.currentRequestId = null;
      this.isLoading = false;
      this.abortController = undefined;

      // Reset progress UI
      this.reportProgress(0, 1);
    }
  }

  /**
   * End an operation and cleanup resources
   * @param requestId The request ID to end
   */
  endOperation(requestId: string): void {
    if (this.currentRequestId === requestId) {
      this.currentRequestId = null;
      this.isLoading = false;
      this.abortController = undefined;
    } else if (this.currentRequestId !== null) {
      console.warn(
        `[Voice] Attempted to end operation ${requestId} but current is ${this.currentRequestId}`,
      );
    }
  }

  /**
   * @deprecated Use isOperationInProgress() instead
   */
  isLoadingInProgress(): boolean {
    return this.isOperationInProgress();
  }

  /**
   * @deprecated Use cancelOperation() instead
   */
  cancelLoading(): void {
    this.cancelOperation();
  }

  rewindAudio() {
    if (this.audio && !isNaN(this.audio.duration)) {
      this.audio.currentTime = Math.max(0, this.audio.currentTime - 3);
    }
  }

  fastForwardAudio() {
    if (this.audio && !isNaN(this.audio.duration)) {
      this.audio.currentTime = Math.min(
        this.audio.duration,
        this.audio.currentTime + 3,
      );
    }
  }

  setSynthesizeInput(synthesizeInput: SynthesizeInput) {
    this.synthesizeInput = {
      ...this.synthesizeInput,
      ...synthesizeInput,
    };
  }

  setAudio(text: string) {
    this.synthesizeInput.Text = text;
  }

  setSpeed(speed: number) {
    this.speed = speed;
    // Update playback rate in real-time if audio is currently playing
    this.updatePlaybackRate(speed);
    return this.speed;
  }

  setProgressCallback(callback: (progress: number) => void) {
    this.progressCallback = callback;
  }

  setErrorCallback(callback: (error: string) => void) {
    this.errorCallback = callback;
  }

  private reportProgress(current: number, total: number) {
    if (this.progressCallback) {
      const progress = total > 0 ? current / total : 0;
      this.progressCallback(Math.min(1, Math.max(0, progress)));
    }
  }

  private reportError(error: unknown) {
    if (this.errorCallback) {
      let errorMessage = "Network error. Please try again.";

      if (error && typeof error === "object" && "message" in error) {
        const errorObj = error as { message: string };

        if (errorObj.message.includes("NetworkingError")) {
          errorMessage = "Connection failed. Check your internet.";
        } else if (errorObj.message.includes("InvalidAccessKeyId")) {
          errorMessage = "Invalid AWS credentials.";
        } else if (errorObj.message.includes("ThrottlingException")) {
          errorMessage = "Rate limited. Please wait and try again.";
        } else if (errorObj.message.includes("TextLengthExceededException")) {
          errorMessage = "Text too long. Try shorter content.";
        } else {
          errorMessage = `AWS Error: ${errorObj.message}`;
        }
      }

      this.errorCallback(errorMessage);
    }
  }

  updatePlaybackRate(speed: number) {
    if (this.audio && this.audio.src) {
      let fSpeed =
        typeof speed === "number" ? parseFloat(speed.toFixed(2)) : this.speed;

      // Clamp speed to supported range
      if (fSpeed < 0.5) {
        fSpeed = 0.5;
      } else if (fSpeed > 2) {
        fSpeed = 2;
      }

      this.audio.playbackRate = fSpeed;
    }
  }

  setVoice(voice: string) {
    this.synthesizeInput.VoiceId = voice as VoiceId;
    this.voiceChanged = true;
  }

  setLanguageCode(language: string) {
    this.synthesizeInput.LanguageCode = language as LanguageCode;
    this.voiceChanged = true;
  }

  isPlaying() {
    return !this.audio.paused;
  }

  hasEnded() {
    return this.audio.ended;
  }

  getLanguageCode(voice: string) {
    switch (voice) {
      case "Brian":
        return "en-GB";
      case "Emma":
        return "en-GB";
      case "Daniel":
        return "de-DE";
      case "Vicki":
        return "de-DE";
      case "Remi":
        return "fr-FR";
      case "Lea":
        return "fr-FR";
      case "Sergio":
        return "es-ES";
      case "Lucia":
        return "es-ES";
      case "Adriano":
        return "it-IT";
      case "Bianca":
        return "it-IT";
      case "Ola":
        return "pl-PL";
      case "Laura":
        return "nl-NL";
      case "Ines":
        return "pt-PT";
      case "Arlet":
        return "ca-ES";
      case "Elin":
        return "sv-SE";
      case "Sofie":
        return "da-DK";
      case "Ida":
        return "nb-NO";
      case "Suvi":
        return "fi-FI";
      case "Takumi":
        return "ja-JP";
      case "Tomoko":
        return "ja-JP";
      case "Kajal":
        return "hi-IN";
      case "Seoyeon":
        return "ko-KR";
      case "Zhiyu":
        return "cmn-CN";
      default:
        return "en-US";
    }
  }

  getContent() {
    return this.synthesizeInput.Text;
  }

  getVoice() {
    return this.synthesizeInput.VoiceId;
  }

  getAudio() {
    return this.audio;
  }

  getSpeed() {
    return this.speed;
  }

  getDuration() {
    return this.audio.duration;
  }

  getCurrentTime() {
    return this.audio.currentTime;
  }

  getVolume() {
    return this.audio.volume;
  }

  private chunkText(text: string, chunkSize: number): string[] {
    const words: string[] = text.split(" ");
    const chunks: string[] = [];
    let startIndex = 0;

    while (startIndex < words.length) {
      const chunk = words.slice(startIndex, startIndex + chunkSize).join(" ");
      chunks.push(chunk);
      startIndex += chunkSize;
    }

    return chunks;
  }

  /**
   * Get the last generated audio blob for download
   * @param filePath - Path of the current file to validate cache
   * @returns The cached audio blob or null if not available or doesn't match file
   */
  getLastGeneratedAudio(filePath?: string): Blob | null {
    // If file path is provided, validate it matches the cached audio's file
    if (filePath && this.lastGeneratedAudioFilePath !== filePath) {
      return null;
    }
    return this.lastGeneratedAudio;
  }

  /**
   * Clear the cached audio blob to free memory
   */
  clearCachedAudio(): void {
    this.lastGeneratedAudio = null;
    this.lastGeneratedAudioFilePath = null;
  }

  /**
   * Set the cached audio with file path tracking
   * @param audioBlob - The audio blob to cache
   * @param filePath - Path of the file this audio belongs to
   */
  setCachedAudio(audioBlob: Blob, filePath: string): void {
    this.lastGeneratedAudio = audioBlob;
    this.lastGeneratedAudioFilePath = filePath;
  }
}
